import jsPDF from 'jspdf';

export const exportChatToPDF = (messages, selectedUser, authUser) => {
  if (!messages || messages.length === 0) {
    throw new Error('No messages to export');
  }

  const pdf = new jsPDF('p', 'mm', 'a4');
  const pageWidth = 190; // A4 width minus margins
  const pageHeight = 277; // A4 height minus margins
  const marginLeft = 10;
  const marginTop = 10;
  let currentY = marginTop;

  // Set font
  pdf.setFont('helvetica');

  // Add header
  pdf.setFontSize(16);
  pdf.setTextColor(0, 0, 0);
  pdf.text('Chat Export', marginLeft, currentY);
  currentY += 8;

  pdf.setFontSize(12);
  pdf.setTextColor(100, 100, 100);
  pdf.text(`Conversation with ${selectedUser.fullName}`, marginLeft, currentY);
  currentY += 6;
  pdf.text(`Exported on: ${new Date().toLocaleString()}`, marginLeft, currentY);
  currentY += 6;
  pdf.text(`Total messages: ${messages.length}`, marginLeft, currentY);
  currentY += 10;

  // Add separator line
  pdf.setDrawColor(200, 200, 200);
  pdf.line(marginLeft, currentY, marginLeft + pageWidth, currentY);
  currentY += 8;

  // Process messages
  for (let i = 0; i < messages.length; i++) {
    const message = messages[i];
    const isOwnMessage = message.senderId === authUser._id;
    const senderName = isOwnMessage ? 'You' : selectedUser.fullName;
    const timestamp = new Date(message.createdAt).toLocaleString();

    // Check if we need a new page
    if (currentY > pageHeight - 30) {
      pdf.addPage();
      currentY = marginTop;
    }

    // Message container
    const messageWidth = pageWidth * 0.75;
    const startX = isOwnMessage ? marginLeft + (pageWidth - messageWidth) : marginLeft;
    
    // Add visual distinction for own messages
    if (isOwnMessage) {
      pdf.setFillColor(240, 248, 255); // Light blue background
      pdf.rect(startX - 2, currentY - 2, messageWidth + 4, 20, 'F');
    } else {
      pdf.setFillColor(248, 248, 248); // Light gray background
      pdf.rect(startX - 2, currentY - 2, messageWidth + 4, 20, 'F');
    }

    // Sender name
    pdf.setFontSize(10);
    pdf.setTextColor(60, 60, 60);
    pdf.setFont('helvetica', 'bold');
    pdf.text(senderName, startX, currentY);
    currentY += 5;

    // Message content
    if (message.text) {
      pdf.setFontSize(11);
      pdf.setTextColor(0, 0, 0);
      pdf.setFont('helvetica', 'normal');
      
      // Split long text into multiple lines
      const textLines = pdf.splitTextToSize(message.text, messageWidth - 10);
      
      // Check if message fits on current page
      const messageHeight = textLines.length * 5 + 12;
      if (currentY + messageHeight > pageHeight - 10) {
        pdf.addPage();
        currentY = marginTop;
        
        // Re-add sender name on new page
        pdf.setFontSize(10);
        pdf.setTextColor(60, 60, 60);
        pdf.setFont('helvetica', 'bold');
        pdf.text(senderName, startX, currentY);
        currentY += 5;
        
        pdf.setFontSize(11);
        pdf.setTextColor(0, 0, 0);
        pdf.setFont('helvetica', 'normal');
      }
      
      // Add each line of text
      for (let line of textLines) {
        pdf.text(line, startX + 2, currentY);
        currentY += 5;
      }
    }

    // Image indicator
    if (message.image) {
      pdf.setFontSize(9);
      pdf.setTextColor(120, 120, 120);
      pdf.setFont('helvetica', 'italic');
      pdf.text('ðŸ“· [Image attachment]', startX + 2, currentY);
      currentY += 4;
    }

    // Timestamp
    pdf.setFontSize(8);
    pdf.setTextColor(150, 150, 150);
    pdf.setFont('helvetica', 'normal');
    pdf.text(timestamp, startX + 2, currentY);
    currentY += 8;

    // Add some space between messages
    currentY += 3;
  }

  // Add footer on last page
  const totalPages = pdf.internal.getNumberOfPages();
  for (let i = 1; i <= totalPages; i++) {
    pdf.setPage(i);
    pdf.setFontSize(8);
    pdf.setTextColor(150, 150, 150);
    pdf.text(`Page ${i} of ${totalPages}`, marginLeft, pageHeight + 5);
    pdf.text('Generated by Chat App', marginLeft + pageWidth - 40, pageHeight + 5);
  }

  // Generate filename
  const safeUserName = selectedUser.fullName.replace(/[^a-zA-Z0-9]/g, '-');
  const dateStr = new Date().toISOString().split('T')[0];
  const fileName = `chat-${safeUserName}-${dateStr}.pdf`;

  return { pdf, fileName };
};

export const formatMessageForPDF = (text, maxLength = 100) => {
  if (!text) return '';
  
  // Escape special characters
  const escaped = text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
  
  // Truncate if too long
  if (escaped.length > maxLength) {
    return escaped.substring(0, maxLength) + '...';
  }
  
  return escaped;
};

export const getMessageStats = (messages, authUserId) => {
  const stats = {
    total: messages.length,
    sent: 0,
    received: 0,
    withImages: 0,
    dateRange: null
  };

  if (messages.length === 0) return stats;

  let earliestDate = new Date(messages[0].createdAt);
  let latestDate = new Date(messages[0].createdAt);

  messages.forEach(message => {
    const messageDate = new Date(message.createdAt);
    
    if (messageDate < earliestDate) earliestDate = messageDate;
    if (messageDate > latestDate) latestDate = messageDate;
    
    if (message.senderId === authUserId) {
      stats.sent++;
    } else {
      stats.received++;
    }
    
    if (message.image) {
      stats.withImages++;
    }
  });

  stats.dateRange = {
    start: earliestDate.toLocaleDateString(),
    end: latestDate.toLocaleDateString()
  };

  return stats;
};
